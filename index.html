<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kruskal Web â€” Constructor de Grafos</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 24px; max-width: 980px; }
    h1 { margin-bottom: 8px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 14px 0; }
    label { display: inline-flex; gap: 8px; align-items: center; }
    select, input { padding: 8px 10px; border-radius: 10px; border: 1px solid #ccc; }
    button { padding: 8px 12px; border-radius: 10px; border: 1px solid #bbb; background: #f7f7f7; cursor: pointer; }
    button:hover { background: #eee; }
    .edges { display: grid; gap: 10px; margin-top: 10px; }
    .edge-row { display: grid; grid-template-columns: 140px 140px 140px 90px; gap: 10px; align-items: center; }
    .pill { display:inline-block; padding: 6px 10px; border-radius: 999px; border: 1px solid #ddd; }
    .ok { border-color: #2ecc71; }
    .bad { border-color: #e74c3c; }
    .muted { color: #666; }
    .status { display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    .error { color:#b00020; margin-top: 8px; white-space: pre-line; }
    .success { color:#0b6b2d; margin-top: 8px; white-space: pre-line; }
    .footer { margin-top: 20px; color:#666; font-size: 14px; }
  </style>
</head>
<body>
  <h1>Kruskal Web</h1>
  <p class="muted">Paso 1: construye tu grafo (A..X). Paso 2 (despuÃ©s): ejecutaremos Kruskal paso a paso.</p>

  <div class="card">
    <div class="row">
      <label>
        NÃºmero de nodos (2â€“24):
        <input id="nInput" type="number" min="2" max="24" value="7" />
      </label>
      <button id="applyN">Aplicar</button>
      <span class="pill" id="nodesLabel">Nodos: â€”</span>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <button id="addEdge">Agregar arista</button>
      <button id="clearEdges">Borrar todas</button>
    </div>

    <div class="status" style="margin-top:10px">
      <span class="pill" id="edgesCount">Aristas: 0</span>
      <span class="pill" id="minEdges">MÃ­nimo requerido: 0</span>
      <span class="pill" id="connectedPill">Conectado: â€”</span>
      <span class="pill" id="validPill">VÃ¡lido: â€”</span>
    </div>

    <div class="edges" id="edgesContainer"></div>

    <div class="error" id="errorBox"></div>
    <div class="success" id="successBox"></div>
  </div>

  <div class="card">
    <button id="continueBtn">Continuar (validar)</button>
    <div class="muted" style="margin-top:10px">
      En la siguiente etapa mostraremos el algoritmo Kruskal paso a paso y el MST.
    </div>
  </div>

  <div class="card" id="kruskalCard" style="display:none">
    <h2 style="margin-top:0">Paso 2: Kruskal (paso a paso)</h2>

    <div class="row">
        <button id="kReset">Reset</button>
        <button id="kStep">Siguiente paso</button>
        <button id="kAuto">Auto</button>
        <button id="kStop" disabled>Stop</button>
    </div>

    <div class="status" style="margin-top:10px">
        <span class="pill" id="kEdgeIdx">Arista: -</span>
        <span class="pill" id="kMstCount">MST: 0</span>
        <span class="pill" id="kTotal">Total: 0</span>
        <span class="pill" id="kDone">Estado: -</span>
    </div>

    <div class="error" id="kError"></div>

    <h3>Vista del grafo</h3>
    <svg id="graphSvg" width="920" height="420"
        style="background:#fff;border:1px solid #eee;border-radius:12px;"></svg>

    <h3>Log</h3>
    <pre id="kLog" style="background:#fafafa;border:1px solid #eee;border-radius:12px;padding:12px;max-height:260px;overflow:auto;"></pre>
  </div>

  <div class="footer">
    Tip: evita aristas duplicadas (Aâ€”B y Bâ€”A cuentan igual). Pesos: enteros 1..100.
  </div>

  <script>
    // ---------- Utils ----------
    const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    const clamp = (x, a, b) => Math.min(b, Math.max(a, x));

    function nodeLabel(idx) { return ALPHABET[idx]; }

    function edgeKey(u, v) {
      // undirected canonical key
      const a = Math.min(u, v), b = Math.max(u, v);
      return `${a}-${b}`;
    }

    // ---------- SVG Graph Drawing ----------
    const svg = document.getElementById("graphSvg");

    function svgClear() {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
    }

    function svgEl(name, attrs = {}) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", name);
        for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, String(v));
        return el;
    }

    function initPositionsIfNeeded() {
        if (state.pos && Object.keys(state.pos).length === state.n) return;

        const W = Number(svg.getAttribute("width"));
        const H = Number(svg.getAttribute("height"));
        const margin = 60;

        const cx = W / 2, cy = H / 2;
        const r = Math.min(W, H) / 2 - margin;

        state.pos = {};
        for (let i = 0; i < state.n; i++) {
            const ang = (2 * Math.PI * i) / state.n - Math.PI / 2;
            state.pos[i] = { x: cx + r * Math.cos(ang), y: cy + r * Math.sin(ang) };
        }
    }

    function drawGraph(graph, highlight = {}) {
        initPositionsIfNeeded();
        const pos = state.pos;

        svgClear();

        const accepted = highlight.accepted || new Set();
        const rejected = highlight.rejected || new Set();
        const currentKey = highlight.currentKey || null;

        // --- aristas ---
        for (const e of graph.edges) {
            const key = edgeKey(e.u, e.v);
            const a = pos[e.u], b = pos[e.v];

            let stroke = "#cfcfcf";
            let width = 2;
            let dash = "";

            if (rejected.has(key)) { stroke = "#9aa0a6"; dash = "6 6"; width = 3; }
            if (accepted.has(key)) { stroke = "#e53935"; dash = ""; width = 4; }
            if (currentKey === key) { stroke = "#fb8c00"; dash = ""; width = 5; }

            svg.appendChild(svgEl("line", {
                x1: a.x, y1: a.y, x2: b.x, y2: b.y,
                stroke, "stroke-width": width, "stroke-dasharray": dash
            }));

            // label peso
            const mx = (a.x + b.x) / 2;
            const my = (a.y + b.y) / 2;

            svg.appendChild(svgEl("rect", {
                x: mx - 12, y: my - 10, width: 24, height: 18,
                fill: "white", opacity: "0.85", rx: 6, ry: 6
            }));

            const text = svgEl("text", {
                x: mx, y: my + 4,
                "text-anchor": "middle",
                "font-size": "12",
                "font-family": "system-ui"
            });
            text.textContent = String(e.w);
            svg.appendChild(text);
        }

        // --- nodos (con drag) ---
        for (let i = 0; i < graph.n; i++) {
            const p = pos[i];

            // grupo para mover cÃ­rculo + texto juntos
            const g = svgEl("g", { "data-node": String(i), style: "cursor: grab;" });

            const circle = svgEl("circle", {
                cx: p.x, cy: p.y, r: 18,
                fill: "#1e40af", stroke: "#0b1220", "stroke-width": 2
            });

            const t = svgEl("text", {
                x: p.x, y: p.y + 5,
                "text-anchor": "middle",
                "font-size": "14",
                "font-weight": "700",
                fill: "white",
                "font-family": "system-ui",
                "pointer-events": "none"
            });
            t.textContent = nodeLabel(i);

            g.appendChild(circle);
            g.appendChild(t);
            svg.appendChild(g);

            // evento mousedown para iniciar drag
            g.addEventListener("mousedown", (ev) => onNodeMouseDown(ev, i));
        }
    }

    let drag = {
        active: false,
        node: null,
        offsetX: 0,
        offsetY: 0,
    };

    function svgPointFromMouseEvent(ev) {
        const rect = svg.getBoundingClientRect();
        return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
    }

    function onNodeMouseDown(ev, nodeIndex) {
        ev.preventDefault();

        initPositionsIfNeeded();
        const p = svgPointFromMouseEvent(ev);
        const cur = state.pos[nodeIndex];

        drag.active = true;
        drag.node = nodeIndex;
        drag.offsetX = cur.x - p.x;
        drag.offsetY = cur.y - p.y;

        // estilo
        const g = ev.currentTarget;
        g.style.cursor = "grabbing";

        // para que aunque salgas del nodo, siga el drag
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("mouseup", onMouseUp);
    }

    function onMouseMove(ev) {
        if (!drag.active) return;

        const W = Number(svg.getAttribute("width"));
        const H = Number(svg.getAttribute("height"));
        const margin = 25; // para que no se vaya fuera del canvas

        const p = svgPointFromMouseEvent(ev);
        const x = clamp(p.x + drag.offsetX, margin, W - margin);
        const y = clamp(p.y + drag.offsetY, margin, H - margin);

        state.pos[drag.node] = { x, y };

        // redibuja manteniendo resaltados actuales si estÃ¡s en Kruskal
        drawGraph(state, { accepted: acceptedSet, rejected: rejectedSet, currentKey });
    }

    function onMouseUp() {
        drag.active = false;
        drag.node = null;

        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("mouseup", onMouseUp);
    }

    // ---------- Union-Find ----------
    class UnionFind {
      constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = Array(n).fill(0);
      }
      find(x) {
        if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);
        return this.parent[x];
      }
      union(a, b) {
        let ra = this.find(a), rb = this.find(b);
        if (ra === rb) return false;
        if (this.rank[ra] < this.rank[rb]) [ra, rb] = [rb, ra];
        this.parent[rb] = ra;
        if (this.rank[ra] === this.rank[rb]) this.rank[ra]++;
        return true;
      }
    }

    function isConnected(n, edges) {
      if (n <= 1) return true;
      if (edges.length === 0) return false;

      const uf = new UnionFind(n);
      for (const e of edges) uf.union(e.u, e.v);

      const root0 = uf.find(0);
      for (let i = 1; i < n; i++) {
        if (uf.find(i) !== root0) return false;
      }
      return true;
    }

    // ---------- State ----------
    const state = {
        n: 7,
        edges: [],
        pos: null, // <-- posiciones { 0:{x,y}, 1:{x,y}, ... }
    };

    // ---------- DOM ----------
    const nInput = document.getElementById("nInput");
    const applyN = document.getElementById("applyN");
    const nodesLabel = document.getElementById("nodesLabel");

    const addEdgeBtn = document.getElementById("addEdge");
    const clearEdgesBtn = document.getElementById("clearEdges");
    const edgesContainer = document.getElementById("edgesContainer");

    const edgesCount = document.getElementById("edgesCount");
    const minEdges = document.getElementById("minEdges");
    const connectedPill = document.getElementById("connectedPill");
    const validPill = document.getElementById("validPill");

    const errorBox = document.getElementById("errorBox");
    const successBox = document.getElementById("successBox");

    const continueBtn = document.getElementById("continueBtn");

    // ---------- Rendering ----------
    function renderNodesLabel() {
      const labels = Array.from({ length: state.n }, (_, i) => nodeLabel(i)).join(", ");
      nodesLabel.textContent = `Nodos: ${labels}`;
    }

    function makeNodeSelect(value, onChange, forbiddenValue = null) {
      const sel = document.createElement("select");
      for (let i = 0; i < state.n; i++) {
        if (forbiddenValue !== null && i === forbiddenValue) continue;
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = nodeLabel(i);
        sel.appendChild(opt);
      }
      sel.value = String(value);
      sel.onchange = () => onChange(Number(sel.value));
      return sel;
    }

    function renderEdges() {
      edgesContainer.innerHTML = "";

      state.edges.forEach((e, idx) => {
        const row = document.createElement("div");
        row.className = "edge-row";

        // Node 1 select
        const uSel = makeNodeSelect(e.u, (newU) => {
          // if newU would equal v, auto-adjust v
          e.u = newU;
          if (e.u === e.v) {
            e.v = (e.v + 1) % state.n;
            if (e.v === e.u) e.v = (e.u + 1) % state.n;
          }
          renderAll();
        }, null);

        // Weight input
        const wInp = document.createElement("input");
        wInp.type = "number";
        wInp.min = "1";
        wInp.max = "100";
        wInp.step = "1";
        wInp.value = String(e.w);
        wInp.oninput = () => {
          e.w = Number(wInp.value);
          renderStatus();
        };

        // Node 2 select (forbidden = current u)
        const vSel = makeNodeSelect(e.v, (newV) => {
          e.v = newV;
          renderAll();
        }, e.u);

        // Delete
        const delBtn = document.createElement("button");
        delBtn.textContent = "Eliminar";
        delBtn.onclick = () => {
          state.edges.splice(idx, 1);
          renderAll();
        };

        row.appendChild(uSel);
        row.appendChild(wInp);
        row.appendChild(vSel);
        row.appendChild(delBtn);

        edgesContainer.appendChild(row);
      });
    }

    function validate() {
      const errors = [];
      const n = state.n;
      const E = state.edges.length;

      // weights and nodes
      for (let i = 0; i < state.edges.length; i++) {
        const e = state.edges[i];
        if (e.u === e.v) errors.push(`Arista #${i+1}: u y v no pueden ser iguales.`);
        if (!Number.isInteger(e.w) || e.w < 1 || e.w > 100) {
          errors.push(`Arista #${i+1}: peso invÃ¡lido (${e.w}). Debe ser entero 1..100.`);
        }
        if (e.u < 0 || e.u >= n || e.v < 0 || e.v >= n) {
          errors.push(`Arista #${i+1}: nodo fuera de rango.`);
        }
      }

      // duplicates (undirected)
      const seen = new Set();
      for (let i = 0; i < state.edges.length; i++) {
        const e = state.edges[i];
        const key = edgeKey(e.u, e.v);
        if (seen.has(key)) errors.push(`Arista duplicada detectada: ${nodeLabel(Math.min(e.u,e.v))}â€”${nodeLabel(Math.max(e.u,e.v))}.`);
        seen.add(key);
      }

      // minimum edges
      const minE = n - 1;
      if (E < minE) errors.push(`El grafo tiene ${E} aristas, pero el mÃ­nimo requerido es ${minE} (N-1).`);

      // connectedness
      const connected = isConnected(n, state.edges);
      if (!connected) errors.push(`El grafo NO estÃ¡ conectado (hay nodos aislados o componentes separados).`);

      return { ok: errors.length === 0, errors, connected };
    }

    function renderStatus() {
      const n = state.n;
      const E = state.edges.length;
      edgesCount.textContent = `Aristas: ${E}`;
      minEdges.textContent = `MÃ­nimo requerido: ${n - 1}`;

      const { ok, errors, connected } = validate();

      connectedPill.textContent = `Conectado: ${connected ? "SÃ­" : "No"}`;
      connectedPill.className = "pill " + (connected ? "ok" : "bad");

      validPill.textContent = `VÃ¡lido: ${ok ? "SÃ­" : "No"}`;
      validPill.className = "pill " + (ok ? "ok" : "bad");

      errorBox.textContent = ok ? "" : errors.map(e => "â€¢ " + e).join("\n");
      successBox.textContent = ok ? "âœ… Grafo vÃ¡lido. Ya puedes continuar a Kruskal." : "";
    }

    function renderAll() {
      renderNodesLabel();
      renderEdges();
      renderStatus();
    }

    // ---------- Actions ----------
    applyN.onclick = () => {
      const n = clamp(Number(nInput.value), 2, 24);
      if (!Number.isInteger(n)) {
        alert("N debe ser un entero.");
        return;
      }
      state.n = n;
      state.edges = []; // reinicia para evitar inconsistencias
      state.pos = null;
      renderAll();
    };

    addEdgeBtn.onclick = () => {
      if (state.n < 2) return;

      // default u=0, v=1, weight=1; adjust to avoid equality
      const u = 0;
      const v = state.n > 1 ? 1 : 0;
      state.edges.push({ u, v, w: 1 });
      renderAll();
    };

    clearEdgesBtn.onclick = () => {
      state.edges = [];
      renderAll();
    };

    continueBtn.onclick = () => {
      const { ok, errors } = validate();
      if (!ok) {
        alert("No se puede continuar:\n\n" + errors.join("\n"));
        return;
      }

      // mostrar etapa 2
      kruskalCard.style.display = "block";
      kStart(state);

      // baja hacia la secciÃ³n
      kruskalCard.scrollIntoView({ behavior: "smooth" });
    };

        // ---------- Kruskal Step-by-Step ----------
    let kState = null;
    let kTimer = null;
    let acceptedSet = new Set();
    let rejectedSet = new Set();
    let currentKey = null;

    function kruskalInit(graph) {
      // graph: { n, edges: [{u,v,w}] }
      // returns a state machine to step through
      const edgesSorted = graph.edges
        .map((e, i) => ({ ...e, _id: i }))
        .sort((a, b) => a.w - b.w || edgeKey(a.u, a.v).localeCompare(edgeKey(b.u, b.v)));

      const uf = new UnionFind(graph.n);

      return {
        n: graph.n,
        edges: edgesSorted,
        i: 0,
        mst: [],
        total: 0,
        uf,
        done: false,
        reason: "",
      };
    }

    function kruskalStep(s) {
      if (s.done) return { type: "done", message: s.reason || "Terminado." };

      // ya tenemos MST completo
      if (s.mst.length === s.n - 1) {
        s.done = true;
        s.reason = "âœ… MST completo (N-1 aristas).";
        return { type: "done", message: s.reason };
      }

      // ya no hay aristas que revisar
      if (s.i >= s.edges.length) {
        s.done = true;
        s.reason = "âš ï¸ Se acabaron las aristas antes de completar el MST (Â¿grafo no conectado?).";
        return { type: "done", message: s.reason };
      }

      const e = s.edges[s.i++];
      const ru = s.uf.find(e.u);
      const rv = s.uf.find(e.v);

      if (ru !== rv) {
        s.uf.union(ru, rv);
        s.mst.push({ u: e.u, v: e.v, w: e.w });
        s.total += e.w;
        return {
          type: "accept",
          edge: e,
          message: `ACEPTA ${nodeLabel(e.u)}â€”${nodeLabel(e.v)} (w=${e.w})`
        };
      } else {
        return {
          type: "reject",
          edge: e,
          message: `RECHAZA ${nodeLabel(e.u)}â€”${nodeLabel(e.v)} (w=${e.w}) (ciclo)`
        };
      }
    }

    // ---------- Kruskal UI wiring ----------
    const kruskalCard = document.getElementById("kruskalCard");
    const kReset = document.getElementById("kReset");
    const kStep = document.getElementById("kStep");
    const kAuto = document.getElementById("kAuto");
    const kStop = document.getElementById("kStop");

    const kEdgeIdx = document.getElementById("kEdgeIdx");
    const kMstCount = document.getElementById("kMstCount");
    const kTotal = document.getElementById("kTotal");
    const kDone = document.getElementById("kDone");
    const kLog = document.getElementById("kLog");
    const kError = document.getElementById("kError");

    function kRenderStatus() {
      if (!kState) return;
      kEdgeIdx.textContent = `Arista: ${Math.min(kState.i, kState.edges.length)}/${kState.edges.length}`;
      kMstCount.textContent = `MST: ${kState.mst.length}/${kState.n - 1}`;
      kTotal.textContent = `Total: ${kState.total}`;
      kDone.textContent = `Estado: ${kState.done ? "Terminado" : "En proceso"}`;
      kDone.className = "pill " + (kState.done ? "ok" : "bad");
    }

    function kLogLine(text) {
      kLog.textContent += text + "\n";
      kLog.scrollTop = kLog.scrollHeight;
    }

    function kStopAuto() {
      if (kTimer) {
        clearInterval(kTimer);
        kTimer = null;
      }
      kStop.disabled = true;
      kAuto.disabled = false;
    }

    function kStart(graph) {
      kError.textContent = "";
      kLog.textContent = "";
      kState = kruskalInit(graph);
      kStep.disabled = false;   // ðŸ‘ˆ importante
      kAuto.disabled = false;   // por si quedÃ³ deshabilitado
      kStop.disabled = true;
      kRenderStatus();
      kLogLine("Orden de aristas (por peso):");
      kState.edges.forEach((e, idx) => {
        kLogLine(`${idx+1}. ${nodeLabel(e.u)}â€”${nodeLabel(e.v)} w=${e.w}`);
      });
      kLogLine("----------------------------------------");
      acceptedSet = new Set();
      rejectedSet = new Set();
      currentKey = null;
      drawGraph(state, { accepted: acceptedSet, rejected: rejectedSet, currentKey });
    }

    function kDoStep() {
      if (!kState) return;
      if (kState.done) {
        currentKey = null;
    drawGraph(state, { accepted: acceptedSet, rejected: rejectedSet, currentKey });
        // ya terminÃ³: no hagas nada
        kStep.disabled = true;
        return;
      }
      const ev = kruskalStep(kState);
      if (ev.edge) {currentKey = edgeKey(ev.edge.u, ev.edge.v);}
      if (ev.type === "accept") acceptedSet.add(currentKey);
      if (ev.type === "reject") rejectedSet.add(currentKey);

      drawGraph(state, { accepted: acceptedSet, rejected: rejectedSet, currentKey });
      if (ev.type === "accept") {
        kLogLine("âœ… " + ev.message);
      } else if (ev.type === "reject") {
        kLogLine("âŒ " + ev.message);
      } else {
        kLogLine(ev.message);
      }

      kRenderStatus();

      if (kState.done) {
        kStopAuto();
        kStep.disabled = true;
        kLogLine("----------------------------------------");
        kLogLine("MST final:");
        kState.mst.forEach((e) => kLogLine(`${nodeLabel(e.u)}â€”${nodeLabel(e.v)} w=${e.w}`));
        kLogLine(`Peso total = ${kState.total}`);
      }
    }

    kReset.onclick = () => {
      kStopAuto();
      kStart(state);
    };

    kStep.onclick = () => {
      kDoStep();
    };

    kAuto.onclick = () => {
      if (!kState) return;
      kAuto.disabled = true;
      kStop.disabled = false;
      kTimer = setInterval(() => {
        if (!kState || kState.done) {
          kStopAuto();
          return;
        }
        kDoStep();
      }, 600);
    };

    kStop.onclick = () => kStopAuto();

    // ---------- Init ----------
    renderAll();
  </script>
</body>
</html>